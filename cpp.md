#### 多态性 虚函数和纯虚函数

- **多态性**：封装，继承为基础

	1. 重载多态 (编译期)：**静态多态**函数重载  `函数名相同，参数个数/类型不同`、运算符重载
	2. 子类型多态 (运行期)： **动态多态**虚函数`类的继承中不同层次，函数名、参数个数/类型都相同而功能	不同`
	3. 参数多态性（编译期）：类模板、函数模板
	4. 强制多态（编译期/运行期）：基本类型转换、自定义类型转换

> 封装：把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。关键字：public, protected, private。不写默认为 private。

- **虚函数**：允许派生类中重新定义与子类同名的函数，通过基类指针或引用来访问`基类/派生类` or `父类/子类`

将**可能会被继承的父类**的析构函数设置为虚函数，可以保证当我们 new 一个子类，然后使<u>用基类指针指向该子类对象</u>，释放基类指针时可以采用`动态关联`的方式释放掉子类的空间，**<u>防止内存泄漏</u>**。

C++默认的析构函数不是虚函数：虚函数需要<u>额外的虚函数表和虚表指针，占用额外的内存</u>。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此 C++默认的析构函数不是虚函数，而是<u>只有当需要当作父类时，设置为虚函数</u>。
```cpp
//用virtual修饰成员函数，使其成为虚函数
//父类：Student 子类：Graduate
virtual void display();//student父类中声明为虚函数，即可通过基类指针指向子类调用子类的display函数
Student *pt = &stud1;
pt->display();
pt = &grad1;
pt->display();
```


#### 内存分配

- **栈**：存放**局部变量、函数参数**等，**由编译器自动分配**，变量离开作用域后自动收回内存，可分配的内存空间较小。。
- **堆**：由 `new`分配的内存块，**程序员手动分配与回收**，一般一个`new`就要对应一个 `delete`。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。　
- **全局/静态存储区**：**<u>全局变量</u>**和静态变量，**由编译器自动分配**，生存期从定义开始直到程序结束。，C语言中，全局变量又分为初始化的和未初始化的，在C++中无此区分，他们共同占用同一块内存区。
- **常量存储区**：这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改，如字符串常量"abcd"。
- 程序代区：存放函数题的二进制代码
- **自由存储区**：由`malloc`等分配的内存块，与堆是十分相似的，用`free`来结束生命周期。

#### new、delete与malloc、free

| new delete                                      | malloc free            |
| :---------------------------------------------- | ---------------------- |
| 按照数据类型进行分配内存，会调用<u>构造函数</u> | 按照指定大小分配内存   |
| 返回指定对象的指针                              | 返回void* 需要类型转化 |
| delete 销毁的时候会调用对象的<u>析构函数</u>    | free不能               |
| new 是一个运算符可以重载为`全局函数/成员函数`   | malloc 是一个库函数    |

```cpp
int *p = (int*)malloc(10*sizeof(int));
free(p);
int *p = new p[10];
delete [] p；
  
void * className::operator new(size_t size){}
void * operator new(size_t size){}
```

#### STL- map、set(C++标准模板库)

  **不能包含重复的关键字  关键字为const**

1. map 是关联(数组)容器，存储<u>关键字key value和 mapped value关联的值</u>对。
2. set 是按照特定顺序<u>只保存关键字</u>的容器。
3. 迭代器可以指向容器中的某个元素，通过迭代器就可以读写它指向的元素。从这一点上看，迭代器和指针类似

| 容器   | 数据结构     | 时间复杂度                                                          | 顺序/重复性         | 备注         |
| ------ | ------------ | :----------------------------------------------------------- | ----------- | ------------ |
| vector | 可变大小数组 | 随机读改、尾部插入、尾部删除 O(1) <br>头部插入、头部删除 O(n) `非尾部 慢` | 无序/可重复 | 支持随机访问 |
| list | 双向链表 | 插入、删除 O(1) | 无序/可重复 | 双向顺序访问 |
| map | 红黑树 | 插入、删除、查找 O(log<sub>2</sub>n) | 有序/不重复 | 关键字 - 值 |
| set | 红黑树 | 插入、删除、查找 O(log<sub>2</sub>n) | 有序/不重复 | 只有关键字，应用：过滤停用词 |

```cpp
list<string> list1 = {"hello", "world"};//初始化指定值
list<string> list2(list1); //创建容器为另一容器的拷贝，容器类型需匹配
vector<int> ivec(10,-1);//初始化10个-1的int元素
/* word count */
map<string, size_t> word_count;//size_t 能存储理论上可行的任何类型（包括数组）对象的最大大小, 通常用于数组下标和循环计数。
string word;
while(cin>> word)
{
  if(word == "0")
    break;
  ++word_count[word];

}
for(const auto &w: word_count)
{
  cout << w.first << " occuers " << w.second << ((w.second)>1? " times " : " time ") << endl;
}
```

- pair标准库类型 - utility.h：类型容器，保存两个数据成员

```cpp
vector<pair<char, int> > pvec(word_count.begin(), word_count.end());
stable_sort(pvec.begin(), pvec.end(), isBigger);
```

#### const or #define来定义常量：**用const定义常量**

- const常量有数据类型，而宏常量没有。编译器可以对前者进行数据类型检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生错误(括号 二义性)。
- const常量便于调试，宏常量难以排查错误。

#### 防止内存泄露的方法： 

- `智能指针`：可以方便的管理一个对象的生命期。

[C++智能指针](https://blog.csdn.net/river_lethe/article/details/78733914)~~auto_ptr~~, shared_ptr, weak_ptr, unique_ptr 

因为智能指针就是一个类， 当超出了类的作用域是，类会**自动调用析构函数**，析构函数会自动释放资源。在函数结束时**自动释放内存空间**，不需要手动释放内存空间。

`unique_ptr `： C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以<u>确保一个对象和其相应的资源同一时间只被一个 pointer 拥有</u>。一旦被销毁/开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。

`shared_ptr`：多个智能指针可以**共享**同一个对象，对象的**最末一个拥有者**有责任销毁对象，并清理与该对象相关的所有资源。用**use_count（引用计数）**来表示有几个共享指针使用这块内存，只有当**所有**共享指针都不指向这块内存后，引用计数变0，这块内存才会被自动释放。

`weak_ptr`：允许**共享但不拥有**某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。<u>可解决共享指针**循环引用**造成的内存泄漏。</u>**

- **父类**的析构函数设置为虚函数，可以保证当我们 new 一个子类，然后使<u>用基类指针指向该子类对象</u>，释放基类指针时可以采用`动态关联`的方式释放掉子类的空间，**<u>防止内存泄漏</u>**。

#### 重载/重写/重定义

- 重载：函数名相同，函数的参数个数/类型/参数不完全相同；返回值的类型可以相同/不同。发生在`一个类内部`。

- 重写(/覆盖)：一般发生在子类和父类继承关系之间。子类重新定义父类中有相同名称和参数的`虚函数`。(override)
- 重定义(/隐藏)：`子类重新定义父类中有相同名称的非虚函数 `( 参数列表可以不同 ) ，指子类的函数屏蔽了与其同名的父类函数。可以理解成发生在继承中的重载。



- 对比一下C和C++ 
- 了解红黑树吗？ 哈希表和红黑树有关系吗 
- 代码重用，那虚函数和模板有什么区别，分别适合什么      
- 项目中有遇到过内存泄漏么？知不知道用什么设计模式来避免这个问题
- 数据库 drop，truncate，delete的区别 

- 数组指针，指针特点
- strcut结构体的内存分配
-  linux用吗？熟悉gdb么？下去你可以了解一下，把每个过程分别执行，去观察一下
- 表示同样大小的数据，数组和链表哪个占用空间大




- 写代码，**两个分数相加返回约分后的结果**，代码是写对了但是有点瑕疵，时间效率不够好。（在IDE写分享屏幕给面试官看的）

- 项目的架构图画一下

- **写个字符串拷贝函数** 字符串拷贝还要注意内存重叠的状况

- **写个快速排序**

- 二叉树中序遍历（撕） 

- 堆排序（撕） 

- 双向链表删除节点（撕）  

-   手撕代码：删除链表倒数第n个节点 

-   手撕代码：字符串B的字符是否都出现在字符串A中 

-   hashmap和hash函数的实现 

- 手撕题目：给两个包括大小写和空格的字符串，问去了空格进行压缩之后，不管大小写，判断两个字符串是否相等

- 手撕了三道代码，第一道青蛙爬楼梯，很经典的一道题，递归几行就结束了，第二道最长回文子串，动态规划解决，第三道求两个长方形非公共区域面积。

- 手撕代码（丑数 剑指offer原题） 

- 8 比较两个字符串是否一样，不用strcmp

-  用数组实现深度为100的消息队列，入队出队函数

-   说是有两个比较大的数组，让求它们的交集。（当时也没有限制说时空复杂度要怎么样）就说你先想想，也可以和我交流。 

    想了一会儿（当时不知道为啥，完全没想到用hash做。。），就说了一个把其中一个排序，再遍历另一个去二分查找的思路。 

    面试官说，恩，这样的确是可以做出来的，这样吧，给你20分钟，你写一下吧，排序你可以先假定有这么个函数，后面要是有时间，你再把排序写一下。 

    最后就写了个快排和二分 