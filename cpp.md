#### 多态性 虚函数和纯虚函数

- **多态性**：封装，继承为基础

	1. 重载多态 (**编译**期)：**静态多态**函数重载  `函数名相同，参数个数/类型不同`、运算符重载
	2. 子类型多态 (**运行**期)： **动态多态**虚函数`类的继承中不同层次，函数名、参数个数/类型都相同而功能	不同`
	3. 参数多态性（编译期）：类模板、函数模板
	4. 强制多态（编译期/运行期）：基本类型转换、自定义类型转换

> 封装：把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。关键字：public, protected, private。不写默认为 private。

- **虚函数**：允许派生类中重新定义与子类同名的函数，通过基类指针或引用来访问`基类/派生类` or `父类/子类`

将**可能会被继承的父类**的析构函数设置为虚函数，可以保证当我们 new 一个子类，然后使<u>用基类指针指向该子类对象</u>，释放基类指针时可以采用`动态关联`的方式释放掉子类的空间，**<u>防止内存泄漏</u>**。

C++默认的析构函数不是虚函数：虚函数需要<u>额外的虚函数表和虚表指针，占用额外的内存</u>。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此 C++默认的析构函数不是虚函数，而是<u>只有当需要当作父类时，设置为虚函数</u>。
```cpp
//用virtual修饰成员函数，使其成为虚函数
//父类：Student 子类：Graduate
virtual void display();//student父类中声明为虚函数，即可通过基类指针指向子类调用子类的display函数
Student *pt = &stud1;
pt->display();
pt = &grad1;
pt->display();
```

- **纯虚函数**：动物作为一个基类可以派生出🐱、🐶等子类，但动物本身生成对象明显不合常理。

  （1）= 0说明它是纯虚函数
  （2）const 表明不能修改其数据成员

```cpp
virtual void animalname() const = 0;//包含纯虚函数的类即为抽象类
virtual void animalname() const {cout<<"cat";}; //公用派生类为非抽象类时，对纯虚函数予以重写以实现多态性
```

#### 内存分配

- **栈**：存放**局部变量、函数参数**等，**由编译器自动分配**，变量离开作用域后自动收回内存，可分配的内存空间较小。
- **堆**：由 `new`分配的内存块，**程序员手动分配与回收**，一般一个`new`就要对应一个 `delete`。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。　
- **全局/静态存储区**(数据段)：**<u>全局变量</u>**和**<u>静态变量</u>**，**由编译器自动分配**，生存期从定义开始直到程序结束。，C语言中，全局变量又分为初始化的和未初始化的，在C++中无此区分，他们共同占用同一块内存区。
- **常量存储区**：这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改，如字符串常量"abcd"。
- 程序代区：存放函数题的二进制代码
- **自由存储区**：由`malloc`等分配的内存块，与堆是十分相似的，用`free`来结束生命周期。

#### 静态，全局，局部变量

- **局部变量**：普通的局部变量定义的时候直接定义数据或者在前面加上auto

- **静态局部变量(static)** ：定义时前面加`static`关键字。只有第一次才经历变量定义和初始化，以后多次在调用时不再定义和初始化，而是维持之前上一次调用时执行后这个变量的值。
- **全局变量**： 定义在函数外面的变量，作用域为**各个源文件**。
- **静态全局变量**：解决重名问题。在定义前加`static`关键字， 告诉编译器这个变量只在当前源文件内使用。
- **全局**变量，**静态**局部变量，**静态全局**变量都在`静态存储区`分配空间，而局部变量在`栈`里分配空间

> 若全局变量<u>仅在单个C文件中访问</u>，则可以将这个变量修改为<u>静态全局变量</u>，以降低模块间的耦合度；
> 若全局变量<u>仅由单个函数访问</u>，则可以将这个变量改为该函数的<u>静态局部变量</u>，以降低模块间的耦合度；

#### new、delete与malloc、free

| new delete                                      | malloc free            |
| :---------------------------------------------- | ---------------------- |
| 按照数据类型进行分配内存，会调用<u>构造函数</u> | 按照指定大小分配内存   |
| 返回指定对象的指针                              | 返回void* 需要类型转化 |
| delete 销毁的时候会调用对象的<u>析构函数</u>    | free不能               |
| new 是一个运算符可以重载为`全局函数/成员函数`   | malloc 是一个库函数    |

```cpp
int *p = (int*)malloc(10*sizeof(int));
free(p);
int *p = new p[10];
delete [] p；
  
void * className::operator new(size_t size){}
void * operator new(size_t size){}
```

#### 数组指针与指针数组

```cpp
int *p1[N];
int (*p2)[N];
// “[]”的优先级比 "*"要高
```

* **指针数组**：p1与[]结合为数组，int *表示数组的类型，是存放int型指针的数组。
* **数组指针**：p2与*结合为指针，指向由N个int型元素组成的一维**数组**，是数组的指针。

#### STL- map、set(C++标准模板库)

  **不能包含重复的关键字  关键字为const**

1. map 是关联(数组)容器，存储<u>关键字key value和 mapped value关联的值</u>对。
2. set 是按照特定顺序<u>只保存关键字</u>的容器。
3. 迭代器可以指向容器中的某个元素，通过迭代器就可以读写它指向的元素。从这一点上看，迭代器和指针类似

| 容器   | 数据结构     | 时间复杂度                                                          | 顺序/重复性         | 备注         |
| ------ | ------------ | :----------------------------------------------------------- | ----------- | ------------ |
| vector | 可变大小数组 | 随机读改、尾部插入、尾部删除 O(1) <br>头部插入、头部删除 O(n) `非尾部 慢` | 无序/可重复 | 支持随机访问 |
| list | 双向链表 | 插入、删除 O(1) | 无序/可重复 | 双向顺序访问 |
| map | 红黑树 | 插入、删除、查找 O(log<sub>2</sub>n) | 有序/不重复 | 关键字 - 值 |
| set | 红黑树 | 插入、删除、查找 O(log<sub>2</sub>n) | 有序/不重复 | 只有关键字，应用：过滤停用词 |

```cpp
list<string> list1 = {"hello", "world"};//初始化指定值
list<string> list2(list1); //创建容器为另一容器的拷贝，容器类型需匹配
vector<int> ivec(10,-1);//初始化10个-1的int元素
/* word count */
map<string, size_t> word_count;//size_t 能存储理论上可行的任何类型（包括数组）对象的最大大小, 通常用于数组下标和循环计数。
string word;
while(cin>> word)
{
  if(word == "0")
    break;
  ++word_count[word];

}
for(const auto &w: word_count)
{
  cout << w.first << " occuers " << w.second << ((w.second)>1? " times " : " time ") << endl;
}
```

- **pair标准库类型** - utility.h：类型容器，保存两个数据成员

```cpp
vector<pair<char, int> > pvec(word_count.begin(), word_count.end());
stable_sort(pvec.begin(), pvec.end(), isBigger);
```

#### const or #define来定义常量：**用const定义常量**

- const常量**有数据类型**，而宏常量没有。编译器可以对前者进行数据类型检查。而对后者只进行**字符替换**，没有类型安全检查，并且在字符替换可能会产生错误(括号 二义性)。
- const常量便于调试，宏常量难以排查错误。

#### 防止内存泄露的方法： 

- `智能指针`：可以方便的管理一个对象的生命期。

[C++智能指针](https://blog.csdn.net/river_lethe/article/details/78733914)~~auto_ptr~~, shared_ptr, weak_ptr, unique_ptr 

因为智能指针就是一个类， 当超出了类的作用域是，类会**自动调用析构函数**，析构函数会自动释放资源。在函数结束时**自动释放内存空间**，不需要手动释放内存空间。

`unique_ptr `： C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以<u>确保一个对象和其相应的资源同一时间只被一个 pointer 拥有</u>。一旦被销毁/开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。

`shared_ptr`：多个智能指针可以**共享**同一个对象，对象的**最末一个拥有者**有责任销毁对象，并清理与该对象相关的所有资源。用**use_count（引用计数）**来表示有几个共享指针使用这块内存，只有当**所有**共享指针都不指向这块内存后，引用计数变0，这块内存才会被自动释放。

`weak_ptr`：允许**共享但不拥有**某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。<u>可解决共享指针**循环引用**造成的内存泄漏。</u>**

- **父类**的析构函数设置为虚函数，可以保证当我们 new 一个子类，然后使<u>用基类指针指向该子类对象</u>，释放基类指针时可以采用`动态关联`的方式释放掉子类的空间，**<u>防止内存泄漏</u>**。

#### 🌟重载/重写/重定义

- 重载：函数名相同，函数的参数个数/类型/参数不完全相同；返回值的类型可以相同/不同。发生在`一个类内部`。

- 重写(/覆盖)：一般发生在子类和父类继承关系之间。子类重新定义父类中有相同名称和参数的`虚函数`。(override)
- 重定义(/隐藏)：`子类重新定义父类中有相同名称的非虚函数 `( 参数列表可以不同 ) ，指子类的函数屏蔽了与其同名的父类函数。可以理解成发生在继承中的重载。

|        | 范围         | 函数名 | 参数      | 返回值    | virtual关键字                                                |
| ------ | :----------- | :----- | :-------- | --------- | :----------------------------------------------------------- |
| 重载   | 一个类内部   | 相同   | 不同      | 相同/不同 | 可有可无                                                     |
| 重写   | 父类与子类间 | 相同   | 相同      | 相同      | 父类函数必须有`virtual`，无static➡️覆盖<br>访问修饰符可以不同 |
| 重定义 | 父类与子类间 | 相同   | 相同/不同 | 相同/不同 | 参数相同+父类函数无`virtua`l ➡️隐藏<br>参数不同+父类函数可有可无`virtual` |

#### C和C++对比(模板)

| C | C++                   |
| ---------------------------- | --------------------------------------- |
| 面向过程：基于函数的处理     | 面向对象`封装` `继承 ` `多态`：对象(类) - 封装操作，给出接口 |
| 无泛型编程 | 泛型编程，`compare的函数模板`**不同类型**采用**相同方式**操作<br>vector 泛型类型 - 标准的容器库，find泛型函数。STL标准库 |
| 无函数重载 & 运算符重载 | 函数重载 & 运算符重载 |
| 动态内存分配 malloc free | new delete |

 ```cpp
template <typename T>
int compare(const T &v1, const T &v2)
{
  if(v1 < v2) return -1;
  if(vi > v2) return 1;
  return 0;
}
//不同数据类型，做相同的操作

template <typename T> class Animal{}
template <class Type>  //类型Type替换之前的整型int等具体类型
class compare
{
  public:
		compare(Type a,Type b){...}//main函数定义时：compare<int> C1(3,5);
  	Type max(){...}
}
 ```

#### 🌟代码重用的实现方式

- 模板：不同数据类型做相同操作，如compare函数，比较int/float/具体类
- 虚函数：子类与父类之间，virtual关键字，**函数名/参数/返回值相同** ，eg, 学生与毕业生void display()输出信息不同